<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Raycast Shooter Game – Enhanced</title>
  <style>
    /* Reset and full-screen canvas styling */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #000;
      font-family: sans-serif;
      color: #fff;
    }
    /* The canvas will be sized dynamically via JavaScript */
    #gameCanvas {
      display: block;
      background: #444;
      margin: auto;
    }
    #instructions {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.6);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="instructions">
    <strong>Controls</strong><br>
    WASD: Move (W forward, S backward, A strafe left, D strafe right)<br>
    Move mouse: Pan camera (click the canvas to lock the pointer)<br>
    Left-click: Fire gun
  </div>
  <canvas id="gameCanvas"></canvas>
  
  <script>
    /********************************************************************
     * Raycast Shooter Game – Enhanced Version
     *
     * Modifications:
     * 1. Resizable canvas: The canvas now fills most of the screen,
     *    leaving room for instructions/ads.
     *
     * 2. Enemies: Instead of flat red squares, enemies are drawn as
     *    red 3D–styled floating spheres. Their rendering is skipped if
     *    they are occluded by walls (using a simple ray sample test).
     *
     * 3. Indicator Bar: A bar is drawn at the top with a red dot showing
     *    the direction (relative to the player’s view) of an enemy even if
     *    occluded.
     *
     * 4. Weapon Overlay: A graphic is drawn in the bottom right so it
     *    appears the player is holding a gun.
     *
     * 5. Smoke Trail: When the gun is fired, a smoke trail is drawn from
     *    the tip of the weapon to the projectile target (here assumed to be
     *    the center of the view) that lingers for one second.
     ********************************************************************/

    // -------------------- Global Variables --------------------
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // These will be set on resize.
    let screenWidth, screenHeight, projectionPlaneDist;
    
    // Game constants.
    const FOV = Math.PI / 3; // 60° field of view
    const maxDepth = 20;     // Maximum raycasting depth.
    const moveSpeed = 3.0;   // Movement speed (units per second)
    const mouseSensitivity = 0.002;  // Adjust for desired panning speed

    // Global array for smoke trail effects.
    let smokeTrails = [];

    // -------------------- Resize Handling --------------------
    function resizeCanvas() {
      // Fill about 85% of the available window size.
      canvas.width = window.innerWidth * 0.85;
      canvas.height = window.innerHeight * 0.85;
      screenWidth = canvas.width;
      screenHeight = canvas.height;
      // Recalculate projection plane distance for proper perspective.
      projectionPlaneDist = (screenWidth / 2) / Math.tan(FOV / 2);
    }
    window.addEventListener("resize", resizeCanvas);
    // Call once at load.
    resizeCanvas();

    // -------------------- Game State Variables --------------------
    let map = [];         // Current level map (array of strings)
    let mapWidth = 0;
    let mapHeight = 0;
    let currentLevel = 1;
    let levelCompleteTimestamp = null;
    let gameOver = false;

    // -------------------- Player and Enemies --------------------
    const player = {
      x: 1.5,    // Starting position (reset each level)
      y: 1.5,
      angle: 0   // Facing right initially
    };

    // Array of enemy objects: each with a position and an "alive" flag.
    const enemies = [];

    // -------------------- Seeded Random Generator --------------------
    // Mulberry32: Fast seeded pseudorandom generator.
    function mulberry32(a) {
      return function() {
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      }
    }

    // -------------------- Procedural Level Generation --------------------
    // Generates a maze using recursive backtracking.
    function generateMaze(width, height, rng) {
      let maze = [];
      for (let y = 0; y < height; y++) {
        maze[y] = [];
        for (let x = 0; x < width; x++) {
          maze[y][x] = 1; // Fill with walls.
        }
      }
      function carve(x, y) {
        maze[y][x] = 0; // Mark as passage.
        const directions = [
          { dx: 0, dy: -2 },
          { dx: 2, dy: 0 },
          { dx: 0, dy: 2 },
          { dx: -2, dy: 0 }
        ];
        // Shuffle directions using seeded RNG.
        for (let i = directions.length - 1; i > 0; i--) {
          const j = Math.floor(rng() * (i + 1));
          [directions[i], directions[j]] = [directions[j], directions[i]];
        }
        for (const {dx, dy} of directions) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1) {
            if (maze[ny][nx] === 1) {
              maze[y + dy/2][x + dx/2] = 0;
              carve(nx, ny);
            }
          }
        }
      }
      carve(1, 1);
      return maze;
    }

    // Optionally carve a rectangular room into the maze.
    function addRoom(maze, rng) {
      const height = maze.length;
      const width = maze[0].length;
      let roomWidth = 3 + 2 * Math.floor(rng() * 3); // 3, 5, or 7
      if (roomWidth > width - 2) roomWidth = width - 2;
      if (roomWidth % 2 === 0) roomWidth--;
      let roomHeight = 3 + 2 * Math.floor(rng() * 3);
      if (roomHeight > height - 2) roomHeight = height - 2;
      if (roomHeight % 2 === 0) roomHeight--;
      const x0 = 1 + Math.floor(rng() * (width - roomWidth - 1));
      const y0 = 1 + Math.floor(rng() * (height - roomHeight - 1));
      for (let y = y0; y < y0 + roomHeight; y++) {
        for (let x = x0; x < x0 + roomWidth; x++) {
          maze[y][x] = 0;
        }
      }
    }

    // Generate a level from the maze and room additions.
    function generateLevel(level) {
      const size = 15 + (level - 1) * 2; // Level1:15, Level10:33 (always odd)
      let rng = mulberry32(level * 12345);
      let maze = generateMaze(size, size, rng);
      const roomCount = Math.floor(level / 2);
      for (let i = 0; i < roomCount; i++) {
        addRoom(maze, rng);
      }
      let mapArray = maze.map(row => row.map(cell => cell === 0 ? '0' : '1').join(''));
      return mapArray;
    }

    // Reset the level: generate a new map, reset player position, and position enemies.
    function setLevel(level) {
      currentLevel = level;
      map = generateLevel(level);
      mapHeight = map.length;
      mapWidth = map[0].length;
      // Place the player near the top-left of the map.
      player.x = 1.5;
      player.y = 1.5;
      player.angle = 0;
      enemies.length = 0;
      // Add enemies: up to 5 (or fewer if level < 5).
      const enemyCount = Math.min(level, 5);
      for (let i = 0; i < enemyCount; i++) {
        let enemyRng = mulberry32(level + i + 1000);
        let ex, ey;
        do {
          ex = 1 + Math.floor(enemyRng() * (mapWidth - 2));
          ey = 1 + Math.floor(enemyRng() * (mapHeight - 2));
        } while (map[ey][ex] !== '0' || (ex < 3 && ey < 3));
        enemies.push({ x: ex + 0.5, y: ey + 0.5, alive: true });
      }
    }

    // -------------------- Collision Check --------------------
    // Returns true if the map cell at (x,y) is a wall.
    function isWall(x, y) {
      if (x < 0 || x >= mapWidth || y < 0 || y >= mapHeight) return true;
      return map[y][x] === '1';
    }

    // Check if an enemy is occluded (i.e. a wall exists along the line from the player to the enemy)
    function isOccluded(enemy) {
      let dx = enemy.x - player.x;
      let dy = enemy.y - player.y;
      let dist = Math.hypot(dx, dy);
      const stepSize = 0.05;
      let steps = Math.ceil(dist / stepSize);
      for (let i = 0; i < steps; i++) {
        let t = i / steps;
        let checkX = player.x + dx * t;
        let checkY = player.y + dy * t;
        if (isWall(Math.floor(checkX), Math.floor(checkY))) return true;
      }
      return false;
    }

    // -------------------- Input Handling --------------------
    // Track key states for WASD movement.
    const keys = {};
    window.addEventListener('keydown', (e) => {
      keys[e.code] = true;
      if (["KeyW","KeyA","KeyS","KeyD"].includes(e.code)) {
        e.preventDefault();
      }
    });
    window.addEventListener('keyup', (e) => { keys[e.code] = false; });

    // On canvas click, request pointer lock.
    canvas.addEventListener('click', () => {
      if (document.pointerLockElement !== canvas) {
        canvas.requestPointerLock();
      }
    });

    // Use mouse movement for panning the camera when pointer lock is active.
    document.addEventListener('mousemove', (e) => {
      if (document.pointerLockElement === canvas) {
        player.angle += e.movementX * mouseSensitivity;
        player.angle = (player.angle + 2 * Math.PI) % (2 * Math.PI);
      }
    });

    // -------------------- Gun Firing Logic & Smoke Trail --------------------
    function fireGun() {
      let distance = 0;
      let hitWall = false;
      while (!hitWall && distance < maxDepth) {
        distance += 0.05;
        const testX = player.x + Math.cos(player.angle) * distance;
        const testY = player.y + Math.sin(player.angle) * distance;
        if (isWall(Math.floor(testX), Math.floor(testY))) {
          hitWall = true;
        }
      }
      // Create a smoke trail from the gun tip to the center (target) of the screen.
      // The gun tip is defined relative to the overlay weapon graphic.
      let gunTip = { x: screenWidth - 150, y: screenHeight - 50 };
      let target = { x: screenWidth / 2, y: screenHeight / 2 };
      smokeTrails.push({ start: gunTip, end: target, startTime: performance.now() });

      // Check for enemy hits along the firing line.
      enemies.forEach(enemy => {
        if (!enemy.alive) return;
        const dx = enemy.x - player.x;
        const dy = enemy.y - player.y;
        const enemyDist = Math.hypot(dx, dy);
        let enemyAngle = Math.atan2(dy, dx);
        let angleDiff = enemyAngle - player.angle;
        if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
        if (Math.abs(angleDiff) < 0.1 && enemyDist < distance) {
          enemy.alive = false;
          console.log("Enemy hit!");
        }
      });
    }
    canvas.addEventListener('mousedown', (e) => {
      if (e.button === 0) { // Primary button
        fireGun();
      }
    });

    // -------------------- Smoke Trail Rendering --------------------
    function renderSmokeTrails() {
      let now = performance.now();
      for (let i = smokeTrails.length - 1; i >= 0; i--) {
        let trail = smokeTrails[i];
        let elapsed = now - trail.startTime;
        if (elapsed > 1000) { // Remove after 1 second.
          smokeTrails.splice(i, 1);
          continue;
        }
        let alpha = 1 - (elapsed / 1000);
        ctx.strokeStyle = "rgba(128,128,128," + alpha + ")";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(trail.start.x, trail.start.y);
        ctx.lineTo(trail.end.x, trail.end.y);
        ctx.stroke();
      }
    }

    // -------------------- Game Update Logic --------------------
    let lastTime = performance.now();
    function update(deltaTime) {
      if (gameOver) return;
      const moveStep = moveSpeed * deltaTime;
      let newX = player.x;
      let newY = player.y;
      // Forward/backward movement (W/S)
      if (keys["KeyW"]) {
        newX += Math.cos(player.angle) * moveStep;
        newY += Math.sin(player.angle) * moveStep;
      }
      if (keys["KeyS"]) {
        newX -= Math.cos(player.angle) * moveStep;
        newY -= Math.sin(player.angle) * moveStep;
      }
      // Strafing: using a rotated vector for left/right.
      if (keys["KeyD"]) {
        newX += Math.cos(player.angle + Math.PI/2) * moveStep;
        newY += Math.sin(player.angle + Math.PI/2) * moveStep;
      }
      if (keys["KeyA"]) {
        newX += Math.cos(player.angle - Math.PI/2) * moveStep;
        newY += Math.sin(player.angle - Math.PI/2) * moveStep;
      }
      
      // Collision detection.
      if (!isWall(Math.floor(newX), Math.floor(newY))) {
        player.x = newX;
        player.y = newY;
      }
      // Level progression: Advance when all enemies are defeated.
      if (enemies.length > 0 && enemies.every(e => !e.alive)) {
        if (!levelCompleteTimestamp) {
          levelCompleteTimestamp = performance.now();
        }
        if (performance.now() - levelCompleteTimestamp > 2000) {
          if (currentLevel < 10) {
            setLevel(currentLevel + 1);
          } else {
            gameOver = true;
          }
          levelCompleteTimestamp = null;
        }
      } else {
        levelCompleteTimestamp = null;
      }
    }

    // -------------------- Raycasting Rendering --------------------
    function renderWalls() {
      for (let x = 0; x < screenWidth; x++) {
        const rayScreenPos = (x / screenWidth) - 0.5;
        const rayAngle = player.angle + rayScreenPos * FOV;
        let distance = 0;
        let hit = false;
        while (!hit && distance < maxDepth) {
          distance += 0.02;
          const rayX = player.x + Math.cos(rayAngle) * distance;
          const rayY = player.y + Math.sin(rayAngle) * distance;
          if (isWall(Math.floor(rayX), Math.floor(rayY))) hit = true;
        }
        // Correct for the fish-eye effect.
        const correctedDistance = distance * Math.cos(rayAngle - player.angle);
        const wallHeight = Math.floor((1 / correctedDistance) * projectionPlaneDist);
        // Use a softer grey by capping maximum brightness.
        let shade = Math.floor(200 / (1 + correctedDistance * correctedDistance * 0.1));
        shade = Math.max(Math.min(shade, 200), 50);
        ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
        const sliceX = x;
        const sliceY = (screenHeight / 2) - (wallHeight / 2);
        ctx.fillRect(sliceX, sliceY, 1, wallHeight);
        // Render ceiling and floor.
        ctx.fillStyle = "#333";
        ctx.fillRect(x, 0, 1, sliceY);
        ctx.fillStyle = "#222";
        ctx.fillRect(x, sliceY + wallHeight, 1, screenHeight - (sliceY + wallHeight));
      }
    }

    // -------------------- Enemy Rendering --------------------
    function renderEnemies() {
      let spriteData = [];
      // For each enemy, if in the player's FOV and not occluded, add sprite data.
      enemies.forEach(enemy => {
        if (!enemy.alive) return;
        // Only render if the enemy is not occluded.
        if (isOccluded(enemy)) return;
        const dx = enemy.x - player.x;
        const dy = enemy.y - player.y;
        const enemyDist = Math.hypot(dx, dy);
        let enemyAngle = Math.atan2(dy, dx);
        let angleDiff = enemyAngle - player.angle;
        if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
        if (Math.abs(angleDiff) < (FOV / 2)) {
          const spriteScreenX = Math.floor((0.5 + (angleDiff / FOV)) * screenWidth);
          const spriteHeight = Math.floor(projectionPlaneDist / enemyDist);
          spriteData.push({
            x: spriteScreenX,
            size: spriteHeight,
            distance: enemyDist,
            enemy: enemy
          });
        }
      });
      // Sort by distance from farthest to closest.
      spriteData.sort((a, b) => b.distance - a.distance);
      spriteData.forEach(sprite => {
        const spriteWidth = sprite.size;
        const spriteX = sprite.x - spriteWidth / 2;
        // The sprite is vertically centered; add a slight oscillation (floating effect).
        const oscillation = Math.sin(performance.now() / 200 + sprite.enemy.x * 10) * 5;
        const spriteY = (screenHeight / 2) - (sprite.size / 2) + oscillation;
        // Draw as a 3D sphere using a radial gradient.
        const centerX = spriteX + spriteWidth / 2;
        const centerY = spriteY + sprite.size / 2;
        const radius = sprite.size / 2;
        const gradient = ctx.createRadialGradient(centerX, centerY, radius * 0.2, centerX, centerY, radius);
        gradient.addColorStop(0, "#ff8080");
        gradient.addColorStop(1, "#800000");
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // -------------------- Indicator Bar Rendering --------------------
    function renderEnemyIndicator() {
      const barHeight = 20;
      // Draw semi-transparent background for the indicator bar.
      ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
      ctx.fillRect(0, 0, screenWidth, barHeight);
      let indicatorEnemy = null;
      let minAngleDiff = Infinity;
      enemies.forEach(enemy => {
        if (!enemy.alive) return;
        let dx = enemy.x - player.x;
        let dy = enemy.y - player.y;
        let enemyAngle = Math.atan2(dy, dx);
        let angleDiff = enemyAngle - player.angle;
        if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
        if (Math.abs(angleDiff) < (FOV / 2) && Math.abs(angleDiff) < Math.abs(minAngleDiff)) {
          minAngleDiff = angleDiff;
          indicatorEnemy = enemy;
        }
      });
      if (indicatorEnemy) {
        // Map angleDiff from [-FOV/2, FOV/2] to [0, screenWidth].
        let ratio = (minAngleDiff + (FOV/2)) / FOV;
        let dotX = ratio * screenWidth;
        let dotY = barHeight / 2;
        ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.arc(dotX, dotY, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // -------------------- Weapon Overlay Rendering --------------------
    function renderWeapon() {
      // Draw a simple weapon graphic in the bottom-right of the screen.
      ctx.fillStyle = "#555";
      ctx.beginPath();
      ctx.moveTo(screenWidth - 150, screenHeight - 50);
      ctx.lineTo(screenWidth - 50, screenHeight - 50);
      ctx.lineTo(screenWidth - 70, screenHeight - 100);
      ctx.lineTo(screenWidth - 170, screenHeight - 100);
      ctx.closePath();
      ctx.fill();
    }

    // -------------------- Overlay Rendering --------------------
    // Draws level info, a center reticle, and the enemy indicator.
    function renderOverlay() {
      // Level text and win message.
      ctx.fillStyle = "white";
      ctx.font = "20px sans-serif";
      ctx.fillText(`Level: ${currentLevel}`, 10, 30);
      if (gameOver) {
        ctx.font = "40px sans-serif";
        ctx.fillText("You Win!", screenWidth/2 - 60, screenHeight/2);
      }
      // Center reticle.
      ctx.fillStyle = "white";
      ctx.beginPath();
      ctx.arc(screenWidth / 2, screenHeight / 2, 3, 0, 2 * Math.PI);
      ctx.fill();
      // Draw the enemy indicator bar.
      renderEnemyIndicator();
    }

    // -------------------- Overall Render Function --------------------
    function render() {
      ctx.clearRect(0, 0, screenWidth, screenHeight);
      renderWalls();
      renderEnemies();
      renderSmokeTrails();
      renderOverlay();
      renderWeapon();
    }

    // -------------------- Main Game Loop --------------------
    function gameLoop(currentTime) {
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      update(deltaTime);
      render();
      requestAnimationFrame(gameLoop);
    }

    // -------------------- Start the Game --------------------
    window.addEventListener('load', () => {
      setLevel(1);
      lastTime = performance.now();
      requestAnimationFrame(gameLoop);
    });
  </script>
</body>
</html>
